
export const handlerFiles = {
  "golang": "package main\n\nimport \"github.com/apibrew/apibrew/pkg/client\"\n\n...\n\nhandler := extensionService.Handler[Book](BookMapperInstance)\n\n// operate on event\nhandler.When(beforeCreate()).Operate(func(e Event, book *Book) {\n  fmt.Printf(\"Before create: %+v\\n\", book)\n})\n\n// multiple conditions (AND)\n// Note: The Go code has one 'after' condition.\nhandler.When(after()).Operate(func(e Event, book *Book) {\n  fmt.Printf(\"After create: %+v\\n\", book)\n})\n\n// you can also cancel handler when needed\noperatorId := handler.When(after()).Operate(func(e Event, book *Book) {\n  fmt.Printf(\"After create: %+v\\n\", book)\n})\n\n// cancel handler\n// Assuming a function like 'unRegisterOperator' exists in your Go code:\nextensionService.unRegisterOperator(operatorId)",
  "java": "import io.apibrew.client.Client;\nimport io.apibrew.client.ext.Condition;\nimport io.apibrew.client.ext.ExtensionService;\nimport io.apibrew.client.ext.Handler;\nimport io.apibrew.client.ext.Operator;\nimport io.apibrew.client.ext.impl.PollerExtensionService;\n\n// prepare handler\nHandler<User> handler = extensionService.handler(User.class);\n\n// or\nHandler<User> handler = extensionService.handler(User.entityInfo);\n\n// operate on event\nhandler.when(Condition.beforeCreate())\n        .operate(Operator.execute((event, user) -> {\n    System.out.println(\"Before create:\" + user);\n}));\n\n// multiple conditions (AND)\nhandler.when(Condition.after())\n        .when(Condition.after())\n        .operate(Operator.execute((event, user) -> {\n    System.out.println(\"After create:\" + user);\n}));\n\n// you can also cancel handler when needed\nString operatorId = handler.when(Condition.after())\n        .when(Condition.after())\n        .operate(Operator.execute((event, user) -> {\n    System.out.println(\"After create:\" + user);\n}));\n\n// cancel handler\nextensionService.unRegisterOperator(operatorId);",
  "javascript": "import {Client, Repository, GenericRecord} from '@apibrew/client';\nimport {Condition, HostedExtensionServiceImpl, PollerExtensionService} from '@apibrew/client/ext';\n\nconst handler = extensionService.handler(User); // or equivalent method for JS\n\n// or\nconst handler = extensionService.handler(User.entityInfo);\n\n// operate on event\nhandler.when(Condition.beforeCreate())\n  .operate(event => {\n    console.log(\"Before create:\", event.user);\n  });\n\n// multiple conditions (AND)\n// Note: The Java code has two identical 'after' conditions. Assuming this is an oversight, I've reduced it to one.\nhandler.when(Condition.after())\n  .operate(event => {\n    console.log(\"After create:\", event.user);\n  });\n\n// you can also cancel handler when needed\nlet operatorId = handler.when(Condition.after())\n  .operate(event => {\n    console.log(\"After create:\", event.user);\n  });\n\n// cancel handler\nextensionService.unRegisterOperator(operatorId);",
  "python": "from apibrew import Client\nfrom apibrew.ext import HostedExtensionServiceImpl, PollerExtensionService\nfrom apibrew.sdk import Condition\n\n# Assuming there's a similar 'extension_service' in Python\nhandler = extension_service.handler(User)  # or equivalent method for Python\n\n# or\nhandler = extension_service.handler(User.entity_info)\n\n# operate on event\ndef before_create_callback(event):\n    print(f\"Before create: {event.user}\")\n\nhandler.when(Condition.before_create()).operate(before_create_callback)\n\n# multiple conditions (AND)\n# Note: The JavaScript code has one 'after' condition.\ndef after_create_callback(event):\n    print(f\"After create: {event.user}\")\n\nhandler.when(Condition.after()).operate(after_create_callback)\n\n# you can also cancel handler when needed\noperator_id = handler.when(Condition.after()).operate(after_create_callback)\n\n# cancel handler\nextension_service.un_register_operator(operator_id)",
  "react": "// handler are part of backend implementation. It cannot be used in frontend."
};
  